{"version":3,"sources":["components/Card.js","components/CardList.js","components/SearchBox.js","components/Scroll.js","containers/App.js","serviceWorker.js","index.js"],"names":["Card","name","email","id","className","alt","src","CardList","robots","cardComponent","map","user","i","key","SearchBox","searchfield","searchChange","type","placeholder","onChange","Scroll","props","style","overflowY","border","height","children","App","onSearchChange","event","setState","target","value","state","fetch","then","response","json","users","this","filteredRobots","filter","toLowerCase","includes","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"2OAsBeA,EAjBF,SAAC,GAAuB,IAAtBC,EAAqB,EAArBA,KAAMC,EAAe,EAAfA,MAAOC,EAAQ,EAARA,GACxB,OAGI,kBAAC,WAAD,KACA,yBAAKC,UAAU,uDACf,yBAAKC,IAAI,QAAQC,IAAG,+BAA0BH,EAA1B,cAEhB,6BACI,4BAAKF,GACL,2BAAIC,QCMLK,EAfE,SAAC,GAAgB,IAAdC,EAAa,EAAbA,OAEVC,EAAgBD,EAAOE,KAAK,SAACC,EAAMC,GACrC,OAAO,kBAAC,EAAD,CAAMC,IAAKD,EAClBT,GAAIK,EAAOI,GAAGT,GACdF,KAAMO,EAAOI,GAAGX,KAChBC,MAAOM,EAAOI,GAAGV,WAErB,OACI,6BACCO,EADD,MCFOK,EAXG,SAAC,GAAgC,EAA/BC,YAAgC,IAAnBC,EAAkB,EAAlBA,aAC7B,OACI,kBAAC,WAAD,KACA,yBAAKZ,UAAU,OACf,2BAAOA,UAAU,mCAAmCa,KAAK,SAASC,YAAY,gBAAeC,SAAUH,OCIhGI,G,MARA,SAACC,GACZ,OACI,yBAAKC,MAAO,CAAEC,UAAW,SAAUC,OAAQ,kBAAmBC,OAAQ,WACjEJ,EAAMK,SADX,OCmDOC,E,YA7CX,aAAe,IAAD,8BACV,+CAoBJC,eAAiB,SAACC,GACd,EAAKC,SAAS,CAAEf,YAAac,EAAME,OAAOC,SApB1C,EAAKC,MAAQ,CACTzB,OAAQ,GACRO,YAAa,IAJP,E,iFAQO,IAAD,OAChBmB,MAAM,8CAA8CC,MAAK,SAAAC,GACtD,OAAOA,EAASC,UAChBF,MAAK,SAAAG,GACJ,EAAKR,SAAS,CAACtB,OAAQ8B,S,+BAarB,IAAD,EAC2BC,KAAKN,MAA7BzB,EADH,EACGA,OAAQO,EADX,EACWA,YACVyB,EAAiBhC,EAAOiC,QAAO,SAAAjC,GACjC,OAAOA,EAAOP,KAAKyC,cAAcC,SAAS5B,EAAY2B,kBAG9D,OACI,kBAAC,WAAD,KACA,yBAAKtC,UAAU,MACX,wBAAIA,UAAU,MAAd,eACJ,kBAAC,EAAD,CAAWY,aAAcuB,KAAKX,iBAC9B,kBAAC,EAAD,KACA,kBAAC,EAAD,CAAUpB,OAAQgC,W,GAvCRI,IAAMC,WCIJC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,MCTNC,IAASC,OACO,kBAAC,EAAD,MACEC,SAASC,eAAe,SDwHpC,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBtB,MAAK,SAAAuB,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,a","file":"static/js/main.f6e6087c.chunk.js","sourcesContent":["import React from 'react';\r\nimport { Fragment } from \"react\"\r\n\r\n\r\n//These arguments come from robots.js for dynamic content//\r\nconst Card = ({name, email, id}) => {\r\n    return (\r\n        //Note that we must use className and not class. The class names come from tachyon for quick css//\r\n        //The below example is using JSX. Note that you can only return a single item, such as a single div, or by importing Fragment, we can use a single Fragment tag and use semantic HTML!//\r\n        <Fragment>\r\n        <div className='tc bg-light-green dib br3 pa3 ma2 grow bw2 shadow-5'>\r\n        <img alt='robot' src={`https://robohash.org/${id}?200*200`}/>\r\n\r\n            <div>\r\n                <h2>{name}</h2>\r\n                <p>{email}</p>\r\n            </div>\r\n        </div>\r\n        </Fragment>\r\n    );\r\n}\r\n\r\nexport default Card;","import React from 'react';\r\nimport Card from './Card';\r\n\r\n//Because we have created the 'Card' component, we can now place this inside a single div for react to generate//\r\n//Here we assign each card an id that we pull from robots.js, as well as the values for each property, also pulled from robots.js//\r\n\r\nconst CardList = ({ robots }) => {\r\n    //Now we want to make a loop that will loop through every card object in robots.js, which we can do using the 'map' method://\r\n    const cardComponent = robots.map ((user, i) => {\r\n        return <Card key={i} \r\n        id={robots[i].id} \r\n        name={robots[i].name} \r\n        email={robots[i].email}/>\r\n    })\r\n    return (\r\n        <div>\r\n        {cardComponent};\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default CardList;","import React, { Fragment } from 'react';\r\n\r\nconst SearchBox = ({searchfield, searchChange}) => {\r\n    return (\r\n        <Fragment>\r\n        <div className='pa2'>\r\n        <input className='pa3 ba b--green bg-lightest-blue' type='search' placeholder='Search Robots'onChange={searchChange} />\r\n        \r\n        </div>\r\n        </Fragment>\r\n    );\r\n}\r\n\r\nexport default SearchBox;","import React from 'react';\r\n\r\nconst Scroll = (props) => {\r\n    return (\r\n        <div style={{ overflowY: 'scroll', border: '1px solid black', height: '1000px'}}>\r\n            {props.children};\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default Scroll;","import React, { Fragment } from 'react';\r\nimport CardList from '../components/CardList';\r\nimport SearchBox from '../components/SearchBox';\r\nimport './App.css';\r\nimport Scroll from '../components/Scroll';\r\n\r\n//Search box. In order for the search box to work, we need to know about 'State'. State simply means the description of your app. A state is an object which describes your application. Currently our state consists of the Robots object and the cardlist. State is able to change. We can change the value of the search box, the value of input which will then change the state. The state which describes the application is our robots and whatever is entered in the search box. 'Props' are simply things that come out of state. So a parent feeds state into a child component, as as soon as the child receives the state it becomes a property. The child element can never change the property.//\r\n\r\nclass App extends React.Component {\r\n    //Here we are declaring a constructor which tells the program the current state://\r\n    constructor() {\r\n        super()\r\n        this.state = {\r\n            robots: [],\r\n            searchfield: ''\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        fetch('https://jsonplaceholder.typicode.com/users').then(response => {\r\n           return response.json();\r\n        }).then(users => {\r\n            this.setState({robots: users});\r\n        })\r\n        \r\n    }\r\n    //Everything in the constructor is now the state, this tells the program what can change or be manipulated. If we want to access the current state, we can use 'this.state.(component). For example, this.state.robots//\r\n\r\n    //Now we want to create a function that will allow the search box to work://\r\n\r\n    //We tell the onSearchChange function to set the state from the searchfield as whatever is typed in//\r\n    onSearchChange = (event) => {\r\n        this.setState({ searchfield: event.target.value });\r\n    }\r\n    \r\n    render() {\r\n        const { robots, searchfield } = this.state;\r\n        const filteredRobots = robots.filter(robots =>{\r\n            return robots.name.toLowerCase().includes(searchfield.toLowerCase())\r\n        })\r\n\r\n    return(\r\n        <Fragment>\r\n        <div className='tc'>\r\n            <h1 className='f2'>RoboFriends</h1>\r\n        <SearchBox searchChange={this.onSearchChange}/> \r\n        <Scroll>\r\n        <CardList robots={filteredRobots} />\r\n        </Scroll>\r\n        </div>\r\n        </Fragment>\r\n    ) \r\n    }\r\n};\r\n\r\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './containers/App';\nimport * as serviceWorker from './serviceWorker';\nimport 'tachyons';\n/*Importing the robots object from robots.js allows us to specify dynamic values for the cards, rather than hard-coding each value. We need to wrap the robots object in curly braces as it is Javascript, and there could be multiple exports, rather than the default single export*/\n//import { robots } from './robots';\n\nReactDOM.render(\n                <App />\n                , document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}